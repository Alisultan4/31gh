# Лёша участвует в съёмке очередного ролика BrMeast, и BrMeast попросил Лёшу подготовить 250 тысяч тонн тротила, но Лёша его не расслышал, поэтому он подготовил n
#  коробок. Лёша хочет погрузить эти коробки в грузовики, для этого он расставил их в ряд, i
# -я слева коробка имеет вес ai
#  тонн.

# Все грузовики, которые собирается использовать Лёша, вмещают в себя одинаковое количество коробок, обозначим это количество k
# . Тогда погрузка происходит следующим образом:

# В первый грузовик помещаются первые k
#  коробок,
# Во второй грузовик помещаются вторые k
#  коробок,
# ⋯
# В nk
# -й грузовик помещаются последние k
#  коробок.
# По окончании погрузки в каждом грузовике должно быть ровно k
#  коробок. То есть, если в какой-то момент в грузовик не получится загрузить ровно k
#  коробок, то вариант погрузки с таким k
#  невозможен.

# Лёша ненавидит справедливость, так что он хочет, чтобы максимальная абсолютная разница между суммарным весом каких-либо двух грузовиков была как можно больше. Если грузовик один, эта величина равна 0
# .

# У Лёши есть достаточно много связей, поэтому для каждого 1≤k≤n
#  он может найти такую компанию, что каждый её грузовик вмещает в себя ровно k
#  коробок. Выведите максимальную абсолютную разницу между суммарным весом каких-либо двух грузовиков.

# Входные данные
# Первая строка содержит одно целое число t
#  (1≤t≤104
# ) — количество наборов входных данных.

# Первая строка каждого набора входных данных содержит целое число n
#  (1≤n≤150000
# ) — количество коробок.

# Во второй строке даны n
#  целых чисел a1,a2,…,an
#  (1≤ai≤109
# ) — веса коробок.

# Гарантируется, что сумма n
#  по всем наборам входных данных не превосходит 150000
# .

# Выходные данные
# Для каждого набора данных выведите одно число — ответ на задачу.


def max_weight_difference(t, test_cases):
    results = []

    # Проходимся по каждому тестовому случаю
    for _ in range(t):
        n, weights = test_cases[_]
        
        # Сортируем массив весов коробок
        weights.sort()

        low, high = 1, n
        result = 0

        # Используем бинарный поиск чуточуто
        while low <= high:
            mid = (low + high) // 2
            total_weight = 0

            # Вычисляем суммарный вес mid наиболее тяжелых коробок
            for i in range(mid):
                total_weight += weights[n - 1 - i]

            # Обновляем результат, если текущая разница больше предыдущей
            result = max(result, total_weight)
            low = mid + 1

        results.append(result)

    return results


if __name__ == "__main__":
    t = int(input())
    test_cases = []

    # Считываем входные данные для каждого тестового случая
    for _ in range(t):
        n = int(input())
        weights = list(map(int, input().split()))
        test_cases.append((n, weights))

    # Получаем результаты и выводим их
    results = max_weight_difference(t, test_cases)

    for res in results:
        print(res)
